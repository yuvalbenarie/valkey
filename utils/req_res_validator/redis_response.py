import dataclasses
import functools
import io
import json
import typing

JsonPrimitives = typing.Union[None, bool, int, float, str]
JsonType = typing.Union[JsonPrimitives, typing.List["JsonType"], typing.Dict[str, "JsonType"]]


@dataclasses.dataclass(frozen=True)
class RedisResponse:
    """
    This class represents a Redis response in RESP3
    """
    json_obj: JsonType
    error: bool
    queued: bool

    @classmethod
    def from_file(cls, stream: io.TextIOBase) -> "RedisResponse":
        """
        Read lines from `stream` (generated by logreqres.c) and build the JSON representing the response in RESP3
        """
        type_byte = stream.read(1)
        parser = cls._get_parser(type_byte=type_byte)
        return parser(stream)

    @classmethod
    @functools.cache
    def _get_parsers_mapping(cls) -> typing.Dict[str, typing.Callable[[io.TextIOBase], "RedisResponse"]]:
        return {
            "+": cls._parse_simple_string,
            "-": cls._parse_simple_error,
            "$": cls._parse_blob_string,
            ":": cls._parse_number,
            ",": cls._parse_double,
            "_": cls._parse_null,
            "#": cls._parse_boolean,
            "!": cls._parse_blob_error,
            "=": cls._parse_verbatim_string,
            "(": cls._parse_big_number,
            "*": cls._parse_array_set_or_push,
            "~": cls._parse_array_set_or_push,
            ">": cls._parse_array_set_or_push,
            "%": cls._parse_map,
            "|": cls._parse_attribute,
        }

    @classmethod
    def _get_parser(cls, type_byte: str) -> typing.Callable[[io.TextIOBase], "RedisResponse"]:
        parsers_mapping = cls._get_parsers_mapping()
        return parsers_mapping[type_byte]

    @classmethod
    def _parse_simple_string(cls, stream: io.TextIOBase) -> "RedisResponse":
        string_value = cls._readline(stream)
        return cls(json_obj=string_value, queued=(string_value == "QUEUED"), error=False)

    @classmethod
    def _parse_simple_error(cls, stream: io.TextIOBase) -> "RedisResponse":
        string_value = cls._readline(stream)
        return cls(json_obj=string_value, queued=False, error=False)

    @classmethod
    def _parse_blob_string(cls, stream: io.TextIOBase) -> "RedisResponse":
        blob_length = int(cls._readline(stream))
        string_value = stream.read(blob_length)
        cls._readline(stream)  # read remaining \r\n after blob_length
        return cls(json_obj=string_value, queued=False, error=False)

    @classmethod
    def _parse_number(cls, stream: io.TextIOBase) -> "RedisResponse":
        number_value = int(cls._readline(stream))
        return cls(json_obj=number_value, queued=False, error=False)

    @classmethod
    def _parse_double(cls, stream: io.TextIOBase) -> "RedisResponse":
        double_value = float(cls._readline(stream))
        return cls(json_obj=double_value, queued=False, error=False)

    @classmethod
    def _parse_null(cls, stream: io.TextIOBase) -> "RedisResponse":
        cls._readline(stream)  # read remaining \r\n after the type byte
        return cls(json_obj=None, queued=False, error=False)

    @classmethod
    def _parse_boolean(cls, stream: io.TextIOBase) -> "RedisResponse":
        boolean_value = cls._readline(stream) == "t"
        return cls(json_obj=boolean_value, queued=False, error=False)

    @classmethod
    def _parse_blob_error(cls, stream: io.TextIOBase) -> "RedisResponse":
        blob_length = int(cls._readline(stream))
        string_value = stream.read(blob_length)
        cls._readline(stream)  # read remaining \r\n after blob_length
        return cls(json_obj=string_value, queued=False, error=True)

    @classmethod
    def _parse_verbatim_string(cls, line: str, stream: io.TextIOBase) -> "RedisResponse":
        blob_length = int(cls._readline(stream))
        string_value = stream.read(blob_length)[4:]  # skip "txt:" or "mkd:"
        cls._readline(stream)  # read remaining \r\n after blob_length
        return cls(json_obj=string_value, queued=False, error=False)

    @classmethod
    def _parse_big_number(cls, stream: io.TextIOBase) -> "RedisResponse":
        # big-number is actually a string
        big_number_value = cls._readline(stream)
        return cls(json_obj=big_number_value, queued=False, error=False)

    @classmethod
    def _parse_array_set_or_push(cls, stream: io.TextIOBase) -> "RedisResponse":
        # unfortunately JSON doesn't tell the difference between a list and a set
        sequence_length = int(cls._readline(stream))
        sequence_value = [cls.from_file(stream=stream).json_obj for _ in range(sequence_length)]
        return cls(
            json_obj=sequence_value,
            queued=False,
            error=False,
        )

    @classmethod
    def _parse_map(cls, stream: io.TextIOBase) -> "RedisResponse":
        map_length = int(cls._readline(stream))

        json_obj = {}
        for _ in range(map_length):
            key = cls.from_file(stream=stream)
            # Redis allows fields to be non-strings but JSON doesn't.
            # Luckily, for any kind of response we can validate, the fields are
            # always strings (example: XINFO STREAM)
            # The reason we can't always convert to string is because of DEBUG PROTOCOL MAP
            # which anyway doesn't have a schema
            if isinstance(key.json_obj, str):
                key = key.json_obj

            json_obj[key] = cls.from_file(stream=stream)

        return cls(json_obj=json_obj, queued=False, error=False)

    @classmethod
    def _parse_attribute(cls, stream: io.TextIOWrapper) -> "RedisResponse":
        # Parse the map that comes first, but discard of it, as use what comes next as the actual response.
        cls._parse_map(stream)
        # We don't care about the attributes, read the real response
        return cls.from_file(stream=stream)

    @staticmethod
    def _readline(stream: io.TextIOBase) -> str:
        # RESP3 lines always end with \r\n
        return stream.readline()[:-2]

    def __str__(self):
        return json.dumps(self.json_obj)
